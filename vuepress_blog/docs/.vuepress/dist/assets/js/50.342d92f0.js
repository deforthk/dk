(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{724:function(t,a,s){"use strict";s.r(a);var n=s(3),e=Object(n.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"对-java-平台的理解？-java-是解释执行-，这句话是正确的吗？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#对-java-平台的理解？-java-是解释执行-，这句话是正确的吗？"}},[t._v("#")]),t._v(" 对 Java 平台的理解？“Java 是解释执行”，这句话是正确的吗？")]),t._v(" "),s("ul",[s("li",[t._v("Java特性")])]),t._v(" "),s("p",[t._v("面向对象（封装，继承，多态）")]),t._v(" "),s("p",[t._v("平台无关性（JVM运行.class文件，编译一次，到处运行）")]),t._v(" "),s("p",[t._v("语言（泛型，Lambda）")]),t._v(" "),s("p",[t._v("类库（集合，并发，网络，IO/NIO）")]),t._v(" "),s("p",[t._v("JRE（Java运行环境，JVM，类库）")]),t._v(" "),s("p",[t._v("JDK（Java开发工具，包括JRE，javac，诊断工具）")]),t._v(" "),s("p",[t._v("垃圾回收")]),t._v(" "),s("ul",[s("li",[t._v("Java 是解释执行？No")])]),t._v(" "),s("p",[t._v("（1）Java源代码首先通过javac编译成字节码(.class文件)")]),t._v(" "),s("p",[t._v("（2）运行时，.class文件通过JVM解析或编译运行 解析：通过JVM内嵌的解释器将字节码解释成机器码；编译：JVM提供了JIT(Just In Time Compile 即时编译器)能够在运行时将经常运行的热点代码编译成与本地平台相关的机器码。这种情况下部分热点代码就属于编译执行，而不是解释执行。")]),t._v(" "),s("p",[t._v("（3）AOT编译器: Java 9提供的直接将所有代码编译成机器码执行。")]),t._v(" "),s("h2",{attrs:{id:"怎样理解面向对象-？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#怎样理解面向对象-？"}},[t._v("#")]),t._v(" 怎样理解面向对象 ？")]),t._v(" "),s("p",[t._v("面向对象是利于语言对现实事物进行抽象。")]),t._v(" "),s("p",[t._v("四大特征：")]),t._v(" "),s("p",[t._v("（1）继承：继承是从已有类得到继承信息创建新类的过程")]),t._v(" "),s("p",[t._v("（2）封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。")]),t._v(" "),s("p",[t._v("（3）多态性：多态性是指允许不同子类型的对象对同一消息作出不同的响应。")]),t._v(" "),s("p",[t._v("（4）抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。")]),t._v(" "),s("h2",{attrs:{id:"int-和integer"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#int-和integer"}},[t._v("#")]),t._v(" int 和Integer")]),t._v(" "),s("p",[t._v("（1）Integer 是 int 的包装类，int 则是 java 的一种基本数据类型；")]),t._v(" "),s("p",[t._v("（2）Integer 变量必须实例化后才能使用，而 int 变量不需要；")]),t._v(" "),s("p",[t._v("（3）Integer 实际是对象的引用，当 new 一个 Integer 时，实际上是生成一个引用指向此对象；而 int 则是直接存储数据值；")]),t._v(" "),s("p",[t._v("（4）Integer 的默认值是 null，int 的默认值是 0。")]),t._v(" "),s("h2",{attrs:{id:"和-equals"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#和-equals"}},[t._v("#")]),t._v(" == 和 equals")]),t._v(" "),s("ul",[s("li",[t._v("1.==")])]),t._v(" "),s("p",[t._v("如果比较的是基本数据类型，那么比较的是变量的值")]),t._v(" "),s("p",[t._v("如果比较的是引用数据类型，那么比较的是地址值（两个对象是否指向同一块内存）")]),t._v(" "),s("ul",[s("li",[t._v("2.equals")])]),t._v(" "),s("p",[t._v("如果没重写 equals() 方法比较的是两个对象的地址值")]),t._v(" "),s("p",[t._v("如果重写了 equals() 方法后我们往往比较的是对象中的属性的内容")]),t._v(" "),s("p",[t._v("equals() 方法是从 Object 类中继承的，如果实现类没有重写 Object 类中 equals() 方法，默认的 实现就是使用==")]),t._v(" "),s("ul",[s("li",[t._v("3.eg")])]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" x "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"string"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" y "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"string"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" z "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"string"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("System")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("out"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("x"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v("y"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// true ")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("System")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("out"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("x"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v("z"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// false ")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("System")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("out"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("equals")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("y"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// true ")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("System")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("out"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("equals")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("z"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// true")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br")])]),s("h2",{attrs:{id:"final，finally，finalize"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#final，finally，finalize"}},[t._v("#")]),t._v(" final，finally，finalize")]),t._v(" "),s("ul",[s("li",[t._v("（1）final")])]),t._v(" "),s("p",[t._v("修饰符（关键字）有三种用法：修饰类、变量和方法。")]),t._v(" "),s("p",[t._v("修饰类时，意味着它不能再派生出新的子类，即不能被继承，因此它和 abstract 是反义词。")]),t._v(" "),s("p",[t._v("修饰变量时，该变量使用中不被改变，必须在声明时给定初值，在引用中只能读取不可修改，即为常量。")]),t._v(" "),s("p",[t._v("修饰方法时，也同样只能使用，不能在子类中被重写。匿名内部类访问局部变量时需要使用 final，因为 Innerclass 实际会 copy 一份局部变量，final 可以防止出现数据一致性问题。")]),t._v(" "),s("ul",[s("li",[t._v("（2）finally")])]),t._v(" "),s("p",[t._v("Java 保证重点代码一定要被执行的机制，例如我们可以用 try-finally 或者 try- catch-finally 来进行文件的关闭、JDBC的关闭等。除非在 finally 前执行了 System.exit（）、 try 中死循环、线程被杀死，finally一定被执行。")]),t._v(" "),s("ul",[s("li",[t._v("（3）finalize")])]),t._v(" "),s("p",[t._v("基础类 Object 的一个方法，当垃圾回收器将要回收对象所占内存时之前被调用（该对象 覆盖了finalize()方法），用来保证对象在被垃圾收集前完成特定的资源回收。由于 finalize 执行时间 不确定且可能造成程序死锁、拖慢垃圾收集等问题，Java 9 中将该方法废弃。")]),t._v(" "),s("p",[t._v("优化：使用 Cleaner 配合幻象引用。")]),t._v(" "),s("h2",{attrs:{id:"接口与抽象类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#接口与抽象类"}},[t._v("#")]),t._v(" 接口与抽象类")]),t._v(" "),s("ul",[s("li",[t._v("（1）构造函数")])]),t._v(" "),s("p",[t._v("抽象类可以有构造函数，但不能被实例化（无论其内部是否有抽象方法，都不能实例化）")]),t._v(" "),s("p",[t._v("接口没有构造函数，不能实例化")]),t._v(" "),s("ul",[s("li",[t._v("（2）成员变量")])]),t._v(" "),s("p",[t._v("抽象类可以有普通成员变量；")]),t._v(" "),s("p",[t._v("接口中没有普通成员变量，但是可以有也只能有 public static final的静态常量，并必须赋予初值；")]),t._v(" "),s("ul",[s("li",[t._v("（3）成员方法")])]),t._v(" "),s("p",[t._v("抽象类中可以有非抽象的普通方法，也可以没有抽象方法；")]),t._v(" "),s("p",[t._v("JDK1.8之前，接口中只能有抽象方法（默认使用 public abstract 修饰，也只能使用这个修饰）；")]),t._v(" "),s("p",[t._v("JDK1.8之后，接口中允许有普通方法，但是需要用 default 来定义，同时可以包含 static 方法；")]),t._v(" "),s("ul",[s("li",[t._v("（4）实现方式")])]),t._v(" "),s("p",[t._v("一个类可以实现多个接口，但只能继承一个抽象类")]),t._v(" "),s("p",[t._v("Java 类实现接口使用 implements 关键字，继承抽象")]),t._v(" "),s("p",[t._v("类则是使用 extends 关键字")]),t._v(" "),s("h2",{attrs:{id:"重载（overload）与重写（override）"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#重载（overload）与重写（override）"}},[t._v("#")]),t._v(" 重载（Overload）与重写（Override）")]),t._v(" "),s("p",[t._v("（1）重载是同一个类中，方法名称相同，但是参数或个数不同。与返回值没有关系。")]),t._v(" "),s("p",[t._v("（2）重写是在多个类中，产生继承关系，父类与子类的方法必须相同。")]),t._v(" "),s("h2",{attrs:{id:"object-中的方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#object-中的方法"}},[t._v("#")]),t._v(" Object 中的方法")]),t._v(" "),s("p",[t._v("（1）protected Object clone()---\x3e创建并返回此对象的一个副本。")]),t._v(" "),s("p",[t._v("（2）boolean equals(Object obj)---\x3e指示某个其他对象是否与此对象“相等”。")]),t._v(" "),s("p",[t._v("（3）protected void finalize()---\x3e当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾 回收器调用此方法。")]),t._v(" "),s("p",[t._v("（4）Class<? extendsObject> getClass()---\x3e返回一个对象的运行时类。")]),t._v(" "),s("p",[t._v("（5）int hashCode()---\x3e返回该对象的哈希码值。")]),t._v(" "),s("p",[t._v("（6）void notify()---\x3e唤醒在此对象监视器上等待的单个线程。")]),t._v(" "),s("p",[t._v("（7）void notifyAll()---\x3e唤醒在此对象监视器上等待的所有线程。")]),t._v(" "),s("p",[t._v("（8）String toString()---\x3e返回该对象的字符串表示。")]),t._v(" "),s("p",[t._v("（9）void wait()---\x3e导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。")]),t._v(" "),s("p",[t._v("void wait(long timeout)---\x3e导致当前的线程等待，直到其他线程调用此对象的 notify() 方 法或 notifyAll()方法，或者超过指定的时间量。")]),t._v(" "),s("p",[t._v("void wait(long timeout, int nanos)---\x3e导致当前的线程等待，直到其他线程调用此对象的 notify()。")]),t._v(" "),s("h2",{attrs:{id:"java创建对象方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java创建对象方式"}},[t._v("#")]),t._v(" Java创建对象方式")]),t._v(" "),s("p",[t._v("（1）使用new关键字创建")]),t._v(" "),s("p",[t._v("（2）调用对象的clone()方法")]),t._v(" "),s("p",[t._v("（3）利用反射，调用Class类或者Constructor类的newInstance()方法")]),t._v(" "),s("p",[t._v("（4）利用反序列化，调用ObjectInputStream类的readObject()方法")]),t._v(" "),s("h2",{attrs:{id:"jdk1-8的新特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jdk1-8的新特性"}},[t._v("#")]),t._v(" JDK1.8的新特性")]),t._v(" "),s("p",[t._v("（1）Lambda表达式")]),t._v(" "),s("p",[t._v("（2）函数式接口")]),t._v(" "),s("p",[t._v("（3）方法引用和构造器调用")]),t._v(" "),s("p",[t._v("（4）Stream API")]),t._v(" "),s("p",[t._v("（5）接口中的默认方法和静态方法")]),t._v(" "),s("p",[t._v("（6）新时间日期API")]),t._v(" "),s("p",[t._v("参考资料："),s("a",{attrs:{href:"https://blog.csdn.net/qq_29411737/article/details/80835658",target:"_blank",rel:"noopener noreferrer"}},[t._v("JDK1.8 新特性"),s("OutboundLink")],1)])])}),[],!1,null,null,null);a.default=e.exports}}]);